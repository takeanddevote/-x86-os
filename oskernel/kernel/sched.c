#include "linux/task.h"

extern task_t *get_next_ready_task();
extern void sched_task(void);

task_t *CURRENT = NULL;

/* 
梳理一下任务切换的过程：
1、首先创建一个idle任务描述符，并且手动构造一个现场：
        -返回地址eip、：即任务函数的地址，这样第一次任务调度就能从头执行任务函数。
        -r0栈esp0：即任务自己的栈，指向新分配的内存末尾地址（满减栈）。
    这个现场是第一次调度该任务时恢复的，后续的现场在时钟中断里保存，这样就能循环调度起来了。然后注册进任务链表中，然后进入kernel_main的死循环中。
2、时钟中断到来，从死循环跳转到时钟ISR中，并压栈eflags、cs、eip（此时是内核栈）。
3、时钟ISR检查是否第一次进入任务切换（CURRET==0？），如果是，则不需要保存现场（内核现场），直接执行调度sched即可
4、sched中取出要调度任务描述符，并赋值给CURRET，然后调用汇编函数switch_task执行任务切换。
5、switch_task直接恢复现场即可。

任务退出：
1、任务退出是指任务函数结束后ret返回，那问题来了，ret返回到哪里呢？我们知道ret返回即从栈顶pop返回地址到eip实现返回跳转，也就是说我们需要
    在进入任务函数调用之前，需要压栈一个任务结束处理函数的地址，这样当任务函数ret时就能返回到任务结束处理函数。、
2、任务处理函数要做什么？把任务描述符从链表中去除、释放动态内存资源。

基于时间片和优先级的任务调度：
    创建任务时指定任务的优先级，任务的时间片（一个时间片等于一个时钟中断）值等于优先级。优先级高的任务先执行，且连续执行完任务的时间片，再轮到下一个优先级的任务，
也是同样的过程直到执行完所有任务，再重置所有任务的时间片，再按照优先级先后执行，如此循环反复。
1、如何实现任务的连续调度呢？
    在时钟中断里，判断任务的时间片是否为0，不为0，则时间片减一，并直接中断返回到任务继续执行，如果为0，则保存现场，并执行调度到下一个优先级的任务。
2、如何找到下一个优先级的任务？
    遍历任务链表，找到时间片不为0的最高优先级任务。
3、如何判断重置所有任务的时间片？
    遍历任务链表时，如果发现所有任务的时间片都为0，则重置所有任务的时间片，并调度最高优先级的任务。

任务的睡眠和唤醒：
1、任务的睡眠、唤醒分别指任务进入睡眠状态、ready状态。注意这和延时的区别，任务睡眠时间是不准确的，是个最小的延时时间。
2、任务睡眠时间以系统滴答次数为基准，一次滴答为10ms。每次发生时钟中断，先检查需要唤醒的任务，再执行调度。
3、如何实现任务睡眠？和任务调度是一样的保存现场、恢复现场。正常的调度是时钟中断发起的，而任务睡眠是任务主动发起的任务调度。但这里有个细节，
    中断发起会自动压栈eflags、cs、eip，并关闭中断，那主动的调度要处理eflags的中断标志位，以及eip问题。
4、唤醒后的时间片问题。


用户态切内核态：
1、重新回顾一下CPL、RPL、DPL：
    CPL表示当前所执行代码段的特权级，由cs寄存器的低二位表示（cs.RPL），RPL表示的是段选择子的请求特权级，DPL段描述符的特权级。cs寄存器
不能通过mov的方式直接设置，因为涉及跨段（代码段）。

2、用户态切内核态的方式：
    -门
        ·中断门 - 主流
            硬中断：由硬件触发的中断，如鼠标、键盘等。
            软中断：软件触发的中断，如除零异常。
            int中断：主动触发的中断，如系统调用int 0x80
        ·调用门 - 极少
        ·任务门 - 废弃
        ·陷阱门 - 废弃
    -快速调用
        ·sysenter、sysexit
        ·syscall、sysret

3、内核态返回用户态：通过构造中断返回栈实现内核态返回用户态。
（1）、中断返回栈
    ·系统调用返回：
        iret：eflags、cs、eip（要主动设置ss、esp3）。
        iretd：eflags、cs、eip、ss、esp3。
    ·硬件中断返回：

（2）、所构造的返回栈中，cs是R3的代码段选择子，ss也是r3的栈段选择子，因此需要构造两个r3的段描述符。出于方便，ss和ds共用一个数据段描述符即可。
（3）、回顾一下平坦模式：不同的段有不同的用处，比如执行代码索引cs、访问内存数据索引ds、访问栈索引ss等。段描述符描述了一段地址空间，在32位
平坦模式下，所有的段描述符描述的地址空间都是0-4GB（为虚拟地址。开启分页后），也就是相同的。
（4）、ss和esp3的关系：ss寄存器存储的是栈段选择子，所指向的段描述符描述的是R3（DPL=3）下的内存段，esp3指在R3下的esp，存储r3的栈顶指针。
举个例子：
    对于通过mov的方式访问普通内存：mov eax, [0x1234] 那么cpu就会先从ds中获取段选择子，然后索引对应的数据段描述符获取段基址+偏移0x1234，得到虚拟地址。
    而对于栈的访问，比如push，cpu会先把esp减去4，然后从ss中获取栈段选择子，然后索引对应的段描述符获取段基址+esp，得到虚拟地址，二者的区别是偏移地址的来源
    不同。
（5）x86的寄存器组和arm寄存器组的区别：
    在arm架构中，分为七种异常模式，不同异常模式下设计有专用和公用寄存器组，而对于x86架构，特权级相当于arm架构的异常模式，但是没有像arm那样设置专门的寄存器组。
    而只是限制用户态对特定寄存器访问：gdtr、idtr、CRx等寄存器需要特权级指令访问；硬件权限控制：端口访问需要特权级指令IN、OUT访问等；

4、用户态通过中断门进入内核态的详细流程：
（1）中断门触发中断进入内核态。
（2）栈段切换：进入内核态之前，cpu会自动从用户态的栈切换到内核态的栈，安全考虑。
    ·cpu读取tr寄存器，取出段选择子。
    ·通过段选择子索引gdt表，得到tss任务段描述符。
    ·解析tss段描述符，得到tss数据结构的内存地址。
    ·从tss数据结构中取出ss0和esp0，并赋值给ss和esp寄存器，实现切栈操作。由此可以看出，cpu不管是访问什么数据，只要在内存都要通过段机制、段描述符。

（3）代码段和特权级的切换：实质就是中断的响应过程。
    ·读取idtr寄存器获取idt表，并通过中断号来索引中断描述符。
    ·保存现场压栈ss、esp、eflags、cs、eip（压入哪个栈？）
    ·权限检查，加载段选择子到cs，实现特权级切换，并从段描述符中取出中断服务函数，并跳转。

（4）其它段的切换，如ds、fs、gs等，则需手动设置。
    ·系统调用：
    ·硬件中断：


5、思考下内存、段机制、页表、特权级的关系：
（1）段描述符描述的是一段内存的位置大小、权限、特权级等属性，而页表描述一整个连续的的虚拟地址空间。由于采用平坦模式，段描述符描述的也是
整个虚拟地址空间的属性。用户态的进程通常都是使用同一个段选择子和段描述符，因为在平坦模式下，段选择子主要用于特权级检查，而不是内存区域划分，但是
每个进程都是有自己独立的虚拟地址空间。


6、虚拟地址空间
（1）虚拟地址空间由页表描述，试想一个问题：从用户态切换到内核态时，因为内核态的代码和用户态的代码是属于两个虚拟地址空间的，即位于不同的物理内存
区域，那么进行特权级切换时，就需要进行虚拟地址空间的切换，即页表的切换。为了提高效率，操作系统把虚拟地址空间分为内核空间（高地址部分）和用户空间
（低地址部分），通过设置页表的属性进行访问权限控制。这对所有的进程都是一样的，内核空间部分都是映射到同一个物理内存区域。当从用户态进程进入内核态时，
cpu能直接执行内核空间的代码，而不需要进行页表的切换。
（2）那么如何实现这个内核高地址的映射的？
 */


void sched(void)
{
    task_t *next = get_next_ready_task();
    
    if(CURRENT)
        set_task_ready(CURRENT);

    if(next) { //如果没有ready任务，即不需要切换任务或者说切换回当前任务。
        CURRENT = next;
    }
    CURRENT->state = TASK_RUNNING;
    sched_task();
}

/* 由任务进入睡眠而进行主动调度 */
void sched_by_sleep(void)
{
    CURRENT = get_next_ready_task();
    CURRENT->state = TASK_RUNNING;
    sched_task();
}