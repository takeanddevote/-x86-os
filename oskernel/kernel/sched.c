#include "linux/task.h"

extern task_t *get_next_ready_task();
extern void sched_task(void);

task_t *CURRENT = NULL;

/* 
梳理一下任务切换的过程：
1、首先创建一个idle任务描述符，并且手动构造一个现场：
        -返回地址eip、：即任务函数的地址，这样第一次任务调度就能从头执行任务函数。
        -r0栈esp0：即任务自己的栈，指向新分配的内存末尾地址（满减栈）。
    这个现场是第一次调度该任务时恢复的，后续的现场在时钟中断里保存，这样就能循环调度起来了。然后注册进任务链表中，然后进入kernel_main的死循环中。
2、时钟中断到来，从死循环跳转到时钟ISR中，并压栈eflags、cs、eip（此时是内核栈）。
3、时钟ISR检查是否第一次进入任务切换（CURRET==0？），如果是，则不需要保存现场（内核现场），直接执行调度sched即可
4、sched中取出要调度任务描述符，并赋值给CURRET，然后调用汇编函数switch_task执行任务切换。
5、switch_task直接恢复现场即可。

任务退出：
1、任务退出是指任务函数结束后ret返回，那问题来了，ret返回到哪里呢？我们知道ret返回即从栈顶pop返回地址到eip实现返回跳转，也就是说我们需要
    在进入任务函数调用之前，需要压栈一个任务结束处理函数的地址，这样当任务函数ret时就能返回到任务结束处理函数。、
2、任务处理函数要做什么？把任务描述符从链表中去除、释放动态内存资源。

基于时间片和优先级的任务调度：
    创建任务时指定任务的优先级，任务的时间片（一个时间片等于一个时钟中断）值等于优先级。优先级高的任务先执行，且连续执行完任务的时间片，再轮到下一个优先级的任务，
也是同样的过程直到执行完所有任务，再重置所有任务的时间片，再按照优先级先后执行，如此循环反复。
1、如何实现任务的连续调度呢？
    在时钟中断里，判断任务的时间片是否为0，不为0，则时间片减一，并直接中断返回到任务继续执行，如果为0，则保存现场，并执行调度到下一个优先级的任务。
2、如何找到下一个优先级的任务？
    遍历任务链表，找到时间片不为0的最高优先级任务。
3、如何判断重置所有任务的时间片？
    遍历任务链表时，如果发现所有任务的时间片都为0，则重置所有任务的时间片，并调度最高优先级的任务。

任务的睡眠和唤醒：
1、任务的睡眠、唤醒分别指任务进入睡眠状态、ready状态。注意这和延时的区别，任务睡眠时间是不准确的，是个最小的延时时间。
2、任务睡眠时间以系统滴答次数为基准，一次滴答为10ms。每次发生时钟中断，先检查需要唤醒的任务，再执行调度。
3、如何实现任务睡眠？和任务调度是一样的保存现场、恢复现场。正常的调度是时钟中断发起的，而任务睡眠是任务主动发起的任务调度。但这里有个细节，
    中断发起会自动压栈eflags、cs、eip，并关闭中断，那主动的调度要处理eflags的中断标志位，以及eip问题。
4、唤醒后的时间片问题。
 */
void sched(void)
{
    task_t *next = get_next_ready_task();
    
    if(CURRENT)
        set_task_ready(CURRENT);

    if(next) { //如果没有ready任务，即不需要切换任务或者说切换回当前任务。
        CURRENT = next;
    }
    CURRENT->state = TASK_RUNNING;
    sched_task();
}

/* 由任务进入睡眠而进行主动调度 */
void sched_by_sleep(void)
{
    CURRENT = get_next_ready_task();
    CURRENT->state = TASK_RUNNING;
    sched_task();
}